/**
 * @author      OA Wu <comdan66@gmail.com>
 * @copyright   Copyright (c) 2015 - 2018, Ginkgo
 * @license     http://opensource.org/licenses/MIT  MIT License
 * @link        https://www.ioa.tw/
 */
 
function cc(str, fontColor, backgroundColor, options) {
  if (str === '')
    return '';

  const colors = { n: '30', r: '31', g: '32', y: '33', b: '34', p: '35', c: '36', w: '37' };
  const styles = { underline: '4', blink: '5', reverse: '7', hidden: '8', u: '4', b: '5', r: '7', h: '8' };

  let tmps = [];

  if (typeof options === 'undefined')
    options = [];

  if (typeof options === 'string')
    options = options.split(',').map(Function.prototype.call, String.prototype.trim);
  
  if (Array.isArray(options) && (options = options.map(Function.prototype.call, String.prototype.toLowerCase)).length)
    for(let i = 0; i < options.length; i++)
      if (typeof styles[options[i]] !== 'undefined')
        tmps.push(['\033[' + styles[options[i]] + 'm', '\033[0m']);

  if (typeof backgroundColor !== 'undefined') {
    let c = backgroundColor[0].toLowerCase();
    if (typeof colors[c] !== 'undefined')
      tmps.push(['\033[' + (parseInt(colors[c], 10) + 10) + 'm', '\033[0m']);
  }

  if (typeof fontColor !== 'undefined') {
    if (fontColor.length < 2)
      fontColor += '_';

    let c = fontColor[0], w = fontColor[1];

    w = w === '_' ? c === c.toUpperCase() ? '2' : w : w;
    c = c.toLowerCase();

    if (!['0', '1', '2'].includes(w))
      w = '1';

    w = w !== '0' ? w === '1' ? '0' : '1' : '2';

    if (typeof colors[c] !== 'undefined')
    tmps.push(['\033[' + w + ';' + colors[c] + 'm', '\033[0m']);
  }

  for(let i = 0; i < tmps.length; i++)
    str = tmps[i][0] + str + tmps[i][1];

  return str;
}

function print() {
  process.stdout.write('\r' + Util.format.apply(this, Array.prototype.slice.call(arguments)));
}
function ctrlC() {
  return '過程中若要關閉請直接按鍵盤上的 ' + cc('control', 'W') + cc(' + ', 'w0') + cc('c', 'W') + '\n' + '                                     ' + cc('^^^^^^^^^^^', 'c1');
}

const rootDiv     = '..';
const Path        = require('path');
const FileSystem  = require('fs');
const Util        = require('util');
const Exec        = require('child_process').exec;

const livereloadDirs = [
  rootDiv + Path.sep + 'js',
  rootDiv + Path.sep + 'css',
  rootDiv + Path.sep + 'img',
  rootDiv + Path.sep + '**' + Path.sep + '*.html',
];


let Reload    = null;
let Notifier  = null;
let Chokidar  = null;
let CmdExists = null;

let chokidarIconFontReady = false;
let chokidarScssFileReady = false;
let isListenIconFont      = false;
let isListenScssFile      = false;
let isListenLivereload    = false;
let isNotifierShow        = true;

function main(first) {

  function notifier(title, subtitle, message) {
    isNotifierShow && new Notifier().notify({
      title: title,
      subtitle: subtitle,
      message: message,
      sound: true,
      wait: false,
      timeout: 5,
      closeLabel: '關閉',
      actions: ['不再顯示'],
      dropdownLabel: '其他',
    }, function(err, response, metadata) {
      if (response == 'activate' && metadata.activationValue == '不再顯示')
        isNotifierShow = false;
    });

    return true;
  }

  function isPortTaken(port, closure) {
    const tester = require('net').createServer();

    tester.once('error', function(err) {
      return err.code != 'EADDRINUSE' ? closure(err) : closure(null, true);
    }).once('listening', function() {
      tester.once('close', function() { closure(null, false); }).close();
    }).listen(port);
  }

  function openLivereload() {
    const title = cc('    ➤ ', 'C') + '開啟 LiveReload';
    print(title + cc('… ', 'w0'));

    const server = Reload.createServer();
    const sendAllClients = server.sendAllClients;

    server.sendAllClients = function(data) {
      sendAllClients.bind(server)(data);
      data = JSON.parse(data);
      const name = data.path.replace(Path.resolve(__dirname, rootDiv + Path.sep) + Path.sep, '');
      chokidarIconFontReady && chokidarScssFileReady && print(cc('    ➤ ', 'c2') + cc('[Livereload] ', 'y2') + cc('刷新', 'w') + ' ' + cc(name, 'w2') + cc(' ─ ', 'w0') + cc('成功', 'g') + '\n');
    };

    server.watch(livereloadDirs);
    
    print(title + cc(' ─ ', 'w0') + cc('成功', 'g') + '\n');
    
    finish();
  }

  function buildIconFont(e, p, dir) {
    const name = dir == 'icomoon' ? false : dir;
    const title = cc('    ➤ ', 'c2') + cc('[Icon Fonts] ', 'P') + cc(e, e == '刪除' ? 'w' : 'w') + ' ' + cc(dir, 'w2') + ' 目錄' + cc(' ─ ', 'w0');

    if (e == '刪除') {
      return FileSystem.exists(p = Path.resolve(__dirname, rootDiv + Path.sep + 'scss' + Path.sep + 'icon' + (name ? '-' + name : '') + '.scss'), function(exists) {
        
        if (!exists)
          return chokidarIconFontReady && print(title + cc('成功', 'g') + '\n');

        FileSystem.unlink(p, function(err) {
          return chokidarIconFontReady && (err ? notifier('[Icon Fonts] 錯誤！', '檔案無法刪除', '請至終端機確認錯誤原因！') && print(title + cc('失敗', 'r') + '\n' + '     ' + cc(' ◎ ', 'p2') + '錯誤原因：' + cc(err, 'w2') + '\n\n') : print(title + cc('成功', 'g') + '\n'));
        });
      });
    }
    
    FileSystem.readFile(p, 'utf8', function(err, data) {
      if (err)
        return chokidarIconFontReady && notifier('[Icon Fonts] 錯誤！', '檔案無法讀取', '請至終端機確認錯誤原因！') && print(title + cc('失敗', 'r') + '\n' + '  ' + cc(' ◎ ', 'p2') + '錯誤原因：' + cc(err, 'w2') + '\n\n');

      data = data.match(/\.icon-[a-zA-Z_\-0-9]*:before\s?\{\s*content:\s*"[\\A-Za-z0-9]*";(\s*color:\s*#[A-Za-z0-9]*;)?\s*}/g);
      data = Array.isArray(data) ? data.map(function(v) { return v.replace(/^\.icon-/g, '.icon-' + (name ? name + '-' : '')).replace(/\n/g, ' ').replace(/\{\s*/g, '{ '); }) : [];
      data = '//\n// @author      OA Wu <comdan66@gmail.com>\n// @copyright   Copyright (c) 2015 - 2018, Ginkgo\n// @license     http://opensource.org/licenses/MIT  MIT License\n// @link        https://www.ioa.tw/\n//\n\n' + (data.length ? '@import "Ginkgo-font";\n\n@include font-face("icon' + (name ? '-' + name : '') + '", font-files(\n  "' + (name ? name : 'icomoon') + '/fonts/icomoon.eot",\n  "' + (name ? name : 'icomoon') + '/fonts/icomoon.woff",\n  "' + (name ? name : 'icomoon') + '/fonts/icomoon.ttf",\n  "' + (name ? name : 'icomoon') + '/fonts/icomoon.svg"));\n\n*[class^="icon' + (name ? '-' + name : '') +'-"]:before, *[class*=" icon' + (name ? '-' + name : '') +'-"]:before {\n  font-family: "icon' + (name ? '-' + name : '') + '";\n\n  speak: none;\n  font-style: normal;\n  font-weight: normal;\n  font-variant: normal;\n}\n\n' + data.join('\n') : '@import "Ginkgo-font";');

      p = Path.resolve(__dirname, rootDiv + Path.sep + 'scss' + Path.sep + 'icon' + (name ? '-' + name : '') + '.scss');
      FileSystem.writeFile(p, data, function(err) {
        return chokidarIconFontReady && (err ? notifier('[Icon Fonts] 錯誤！', '檔案無法寫入', '請至終端機確認錯誤原因！') && print(title + cc('失敗', 'r') + '\n' + '     ' + cc(' ◎ ', 'p2') + '錯誤原因：' + cc(err, 'w2') + '\n\n') : print(title + cc('成功', 'g') + '\n'));
      });
    });
  }

  function compileScss(e, p) {
    const css = p.replace(Path.resolve(__dirname, rootDiv + Path.sep + 'scss'), Path.resolve(__dirname, rootDiv + Path.sep + 'css')).replace(/\.scss$/, '.css');

    if (e == '刪除')
      return FileSystem.exists(css, function(exists) {
        const title = cc('    ➤ ', 'c2') + cc('[Scss Files] ', 'b2') + cc(e, 'w') + ' ' + cc(css.replace(Path.resolve(__dirname, rootDiv + Path.sep + 'css') + Path.sep, ''), 'w2') + cc(' ─ ', 'w0');

        if (!exists)
          return chokidarScssFileReady && print(title + cc('成功', 'g') + '\n');

        FileSystem.unlink(css, function(err) {
          chokidarScssFileReady && (err ? notifier('[Scss Files] 錯誤！', '檔案無法刪除', '請至終端機確認錯誤原因！') && print(title + cc('失敗', 'r') + '\n' + '     ' + cc(' ◎ ', 'p2') + '錯誤原因：' + cc(err, 'w2') + '\n\n') : print(title + cc('成功', 'g') + '\n'));
        });
      });

    Exec('compass compile', function(error, stdout, stderr) {
      const token = stdout.replace(/\x1b[[][^A-Za-z]*[A-Za-z]/g, '').split(/\s/).map(Function.prototype.call, String.prototype.trim).filter(function(t) { return t !== ''; });

      if (!token.length)
        return;

      const action = token.shift();
      const file = token.shift();
      let   title = cc('    ➤ ', 'c2') + cc('[Scss Files] ', 'b2') + cc(e, 'w') + ' ';

      if (action == 'write')
        return chokidarScssFileReady && print(title + cc(file.replace(Path.resolve(__dirname, rootDiv + Path.sep + 'css') + Path.sep, ''), 'w2') + cc(' ─ ', 'w0') + cc('成功', 'g') + '\n');
      
      if (action == 'error') {

        const token2 = /\(Line\s*(\d+):\s*(.*)\)/g.exec(token.join(' '));
        title = title + cc(file.replace(Path.resolve(__dirname, rootDiv + Path.sep + 'scss') + Path.sep, ''), 'w2') + cc(' ─ ', 'w0') + cc('失敗', 'r');

        if (!Array.isArray(token2))
          return chokidarScssFileReady && print(title + '\n     ' + cc(' ◎ ', 'p2') + '錯誤原因：' + cc(token.join(' '), 'w2') + '\n');

        title += token2.length >= 2 ? cc(' ─ ', 'w0') + '第 ' + cc(token2[1], 'y2') + ' 行' : '';
        title += token2.length >= 3 ? '\n     ' + cc(' ◎ ', 'p2') + '錯誤原因：' + cc(token2[2], 'w2') + '\n' : '';
        
        return chokidarScssFileReady && notifier('[Scss Files] 錯誤！', '編譯 SCSS 檔案發生錯誤', '請至終端機確認錯誤原因！') && print(title + '\n');
      }
      
      if (token[0] == 'delete')
        return;
    });
  }

  function watchIconFont() {
    const title = cc('    ➤ ', 'C') + '監控 Font 目錄';
    print(title + cc('… ', 'w0'));

    Chokidar.watch(Path.resolve(__dirname, rootDiv + Path.sep + 'font'))
    .on('change', function(p) {
      const tokens = p.replace(Path.resolve(__dirname, rootDiv + Path.sep + 'font'), '').split(Path.sep).map(Function.prototype.call, String.prototype.trim).filter(function(v) { return v.length; });
      tokens.length == 2 && tokens[1] == 'style.css' && buildIconFont('修改', p, tokens[0]);
    })
    .on('add', function(p) {
      const tokens = p.replace(Path.resolve(__dirname, rootDiv + Path.sep + 'font'), '').split(Path.sep).map(Function.prototype.call, String.prototype.trim).filter(function(v) { return v.length; });
      tokens.length == 2 && tokens[1] == 'style.css' && buildIconFont('新增', p, tokens[0]);
    })
    .on('unlink', function(p) {
      const tokens = p.replace(Path.resolve(__dirname, rootDiv + Path.sep + 'font'), '').split(Path.sep).map(Function.prototype.call, String.prototype.trim).filter(function(v) { return v.length; });
      tokens.length == 2 && tokens[1] == 'style.css' && buildIconFont('刪除', p, tokens[0]);
    })
    .on('error', function(err) {
      notifier('[監控 Font 目錄] 警告！', '監控 Font 目錄發生錯誤', '請至終端機確認錯誤原因！');
      print(title + cc(' ─ ', 'w0') + cc('失敗', 'r') + '\n' + '     ' + cc(' ◎ ', 'p2') + '錯誤原因：' + cc(err, 'w2') + '\n');
      return watchScssFile();
    })
    .on('ready', function() {
      print(title + cc(' ─ ', 'w0') + cc('成功', 'g') + '\n');
      isListenIconFont = true;
      setTimeout(function() { chokidarIconFontReady = true; }, 1000);
      return watchScssFile();
    });
  }

  function watchScssFile() {
    const title = cc('    ➤ ', 'C') + '監控 Scss 檔案';
    print(title + cc('… ', 'w0'));

    CmdExists('compass', function(err, exists) {
      if (err)
        return notifier('[監控 Scss 檔案] 錯誤！', '偵測不到 Compass 指令', '請至終端機確認錯誤原因！') && print(title + cc('失敗', 'r') + '\n' + '  ' + cc(' ◎ ', 'p2') + '錯誤原因：' + cc(err, 'w2') + '\n\n');

      if(!exists) {
        notifier('[監控 Scss 檔案] 警告！', '不存在 Compass 指令', '請至終端機確認錯誤原因！') && print(title + cc(' ─ ', 'w0') + cc('失敗', 'r') + '\n' + '     ' + cc(' ◎ ', 'p2') + '無法執行 ' + cc('compass', 'w2') + ' 指令' + '\n' + '     ' + cc(' ◎ ', 'p2') + '請確認終端機是否可以執行 compass 指令。' + '\n');
        return watchLivereloadFile();
      }

      let compassCompileTimer = null;

      Chokidar.watch(Path.resolve(__dirname, rootDiv + Path.sep + 'scss' + Path.sep + '**' + Path.sep + '*.scss'))
      .on('change', function(p) {
        clearTimeout(compassCompileTimer);
        compassCompileTimer = setTimeout(compileScss.bind(null, '修改', p), 250);
      })
      .on('add', function(p) {
        clearTimeout(compassCompileTimer);
        compassCompileTimer = setTimeout(compileScss.bind(null, '新增', p), 250);
      })
      .on('unlink', function(p) {
        setTimeout(compileScss.bind(null, '刪除', p), 250);
      })
      .on('error', function(err) {
        notifier('[監控 Scss 檔案] 警告！', '監控 Scss 檔案發生錯誤', '請至終端機確認錯誤原因！');
        print(title + cc(' ─ ', 'w0') + cc('失敗', 'r') + '\n' + '     ' + cc(' ◎ ', 'p2') + '錯誤原因：' + cc(err, 'w2') + '\n');
        return watchLivereloadFile();
      })
      .on('ready', function() {
        print(title + cc(' ─ ', 'w0') + cc('成功', 'g') + '\n');
        isListenScssFile = true;
        setTimeout(function() { chokidarScssFileReady = true; }, 3000);
        return watchLivereloadFile();
      });
    });
  }

  function watchLivereloadFile() {
    print('\n' + cc(' 【開啟 LiveReload】', 'y') + '\n');
    
    const title = cc('    ➤ ', 'C') + '確認有無其他專案正在使用';
    print(title + cc('… ', 'w0'));

    isPortTaken(35729, function(err, use) {
      if (err !== null || use) {
        print(title + cc(' ─ ', 'w0') + cc('失敗', 'r') + '\n' + '     ' + cc(' ◎ ', 'p2') + (err !== null ? '偵測錯誤，錯誤原因：' + cc(err, 'w2') : '有別的專案開啟了 LiveReload！') + '\n' + '     ' + cc(' ◎ ', 'p2') + ('未啟動 LiveReload 不會影響其他功能！') + '\n');

        notifier('[開啟 LiveReload] 警告！', '啟動 LiveReload 時發生錯誤', err === null ? '您有其他正在執行 LiveReload 的專案。\n本專案無法執行 LiveReload，但不影響其他功能。' : ('無法執行 LiveReload，不明原因錯誤！\n錯誤原因：' + err));
      } else {
        print(title + cc(' ─ ', 'w0') + cc('成功', 'g') + '\n');
        isListenLivereload = true;
      }

      finish();
    });
  }

  function finish() {
    print('\n' + cc(' 【開發工具狀態】', 'y') + '\n');
    print(cc('    ➤ ', 'C') + 'Watch Icon Fonts' + cc(' ─ ', 'w0') + (isListenIconFont   ? cc('已經啟動', 'g') : cc('尚未啟動', 'r')) + '\n');
    print(cc('    ➤ ', 'C') + 'Watch Scss Files' + cc(' ─ ', 'w0') + (isListenScssFile   ? cc('已經啟動', 'g') : cc('尚未啟動', 'r')) + '\n');
    print(cc('    ➤ ', 'C') + 'Watch Livereload' + cc(' ─ ', 'w0') + (isListenLivereload ? cc('已經啟動', 'g') : cc('尚未啟動', 'r')) + '\n');
    
    if (!isListenIconFont && !isListenScssFile && !isListenLivereload)
      return print(cc('    ➤ ', 'C') + '開發工具沒有開啟..' + '\n');

    print(cc('    ➤ ', 'C') + ctrlC());

    print('\n' + cc(' 【紀錄】', 'R') + '\n');
    print(cc('    ➤ ', 'C') + '您可以開始開發囉！' + '\n');
  }
  
  if (first) {
    process.stdout.write('\x1b[2J');
    process.stdout.write('\x1b[0f');
    print('\n' + cc(' 【Ginkgo 開發工具】', 'R') + '\n');
    print(cc('    ➤ ', 'C') + ctrlC());
  } else {
    print('\n');
  }
  
  print('\n' + cc(' 【監控目錄】', 'y') + '\n');

  watchIconFont();
}

try {
  Reload    = require('livereload');
  Notifier  = require('node-notifier').NotificationCenter;
  Chokidar  = require('chokidar');
  CmdExists = require('command-exists');

  return main(true);
} catch(e) {
  process.stdout.write('\x1b[2J');
  process.stdout.write('\x1b[0f');

  print('\n' + cc(' 【Ginkgo 開發工具】', 'R') + '\n');
  print(cc('    ➤ ', 'C') + '第一次使用，所以建立初始化環境' + '\n');
  print(cc('    ➤ ', 'C') + ctrlC());

  print('\n' + cc(' 【建立環境】', 'y') + '\n');
  
  const title = cc('    ➤ ', 'C') + '執行 ' + cc('npm install .', 'w2') + ' 指令';
  print(title + cc('… ', 'w0'));

  Exec('npm install .', function(err, stdout, stderr) {
    const ok = '\n' + '\n' + cc('                                             ', 'r', 'r') + '\n' + cc(' 完成！ ', 'y2', 'r') + cc('已完成初始化環境！                   ', 'n1', 'r') + '\n' + cc('        ', 'y2', 'r') + cc('接著請再執行一次', 'n1', 'r') + cc(' node watch ', 'w2', 'r') + cc('指令吧！ ', 'n1', 'r') + '\n' + cc('                         ', 'r', 'r') + cc('^^^^^^^^^^', 'y2', 'r') + cc('          ', 'r', 'r') + '\n' + '\n';
    const no = '\n' + '\n' + cc('                                            ', 'r', 'r') + '\n' + cc(' 失敗！ ', 'y2', 'r') + cc('不明原因錯誤！                      ', 'n1', 'r') + '\n' + cc('        ', 'y2', 'r') + cc('請在手動執行指令', 'n1', 'r') + cc(' npm install . ', 'w2', 'r') + cc('吧！ ', 'n1', 'r') + '\n' + cc('                         ', 'r', 'r') + cc('^^^^^^^^^^^^^', 'y2', 'r') + cc('      ', 'r', 'r') + '\n' + '\n';

    if (!err) {
      try {
        Reload    = require('livereload');
        Notifier  = require('node-notifier').NotificationCenter;
        Chokidar  = require('chokidar');
        CmdExists = require('command-exists');
        print(title + cc(' ─ ', 'w0') + cc('成功', 'g'));

        return main(false); 
      } catch(e) {
        return print(no) && process.exit(1);
      }
    }

    print(title + cc(' ─ ', 'w0') + cc('警告', 'y') + '\n');
    print('     ' + cc(' ◎ ', 'p2') + cc('cmd 目錄', 'w2') + '權限不可寫入' + '\n');
    print(cc('    ➤ ', 'C') + '改使用最高權限執行 ' + cc('sudo npm install .', 'w2') + ' 指令' + '\n');
    
    Exec('sudo npm install .', function(err, stdout, stderr) {
      if (!err) {
        try {
          Reload    = require('livereload');
          Notifier  = require('node-notifier').NotificationCenter;
          Chokidar  = require('chokidar');
          CmdExists = require('command-exists');
          return main(false);
        } catch(e) {
          return print(no) && process.exit(1);
        }
      }

      return print(no) && process.exit(1);
    });
  });
}